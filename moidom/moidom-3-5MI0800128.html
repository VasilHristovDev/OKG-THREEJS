<!DOCTYPE html>

<!-- Васил Христов, група 3, ф.н. 5MI0800128 -->

<html>
<head>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <script src="three.min.js"></script>
  <script src="OrbitControls.js"></script>
  <title>Vasil Hristov 5MI0800128 MOIDOM</title>
</head>

<body>
<script>
  const FN = '5MI0800128'; // факултетен номер
</script>

<script src="init.js"></script>

<script>
  //TODO: Make all objects cast shadows!!!!
  //TODO: Make all textures load from online and logic if loading fails!!

  // 1. преименувайте файла на moidom-g-fn.html
  //    g=номер на група, а fn=факултетен номер
  //
  // 2. сменете стойността на константата FN да
  //    е факултетния номер, за да се генерират
  //    сцената, земята и контурът на къщата ви
  //
  // 3. едва тогава почвайте да строите стените
  //    и да добавяте исканите обекти по стаите
  //
  // 4. в init.js се прави глобален обект scene
  //    и в него трябва да сложите обектите си!
  //
  // 5. кубът по-долу е само за пример как може
  //    да се слагат обекти, които правят сянка

  //Drawer class
  class Drawer {
    width;
    height;
    depth;

    constructor(width, height, depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
    }

    getObject() {
      const foundation = new THREE.BoxBufferGeometry(this.width -0.05 , 0.01, this.depth - 0.05);
      const frontElement = new THREE.BoxBufferGeometry(this.width - 0.05 , this.height , 0.01);
      const backElement = new THREE.BoxBufferGeometry(this.width - 0.02, this.height - 0.02, 0.01);
      const sideElement = new THREE.BoxBufferGeometry(0.01, this.height - 0.02, this.depth);
      const handle = new THREE.TorusBufferGeometry(0.01, 0.03, 6, 6, 6);

      const textureLoader = new THREE.TextureLoader();
      const whiteWoodMaterial = new THREE.MeshPhongMaterial({map: textureLoader.load("/materials/white-wood.jpg")});
      const handleMaterial = new THREE.MeshPhongMaterial({
        color: 0x000000,
        map: textureLoader.load("/materials/dark-wood.jpg")
      });

      const foundationObj = new THREE.Mesh(foundation, whiteWoodMaterial);
      const sideLeft = new THREE.Mesh(sideElement, whiteWoodMaterial);
      const sideRight = sideLeft.clone();
      const front = new THREE.Mesh(frontElement, whiteWoodMaterial);
      const back = new THREE.Mesh(backElement, whiteWoodMaterial);
      const handleObj = new THREE.Mesh(handle, handleMaterial);

      foundationObj.position.set(0,-this.height/2 + 0.05,0);
      sideLeft.position.set(-this.width/2 + 0.05, 0, 0);
      sideRight.position.set(this.width/2 - 0.05, 0, 0);
      back.position.set(0, 0, this.depth/2 );
      front.position.set(0, 0, -this.depth/2 );
      handleObj.position.set(0, 0, -this.depth/2 );

      sideLeft.castShadow = true;
      sideLeft.receiveShadow = true;
      sideRight.castShadow = true;
      sideRight.receiveShadow = true;
      back.castShadow = true;
      back.receiveShadow = true;
      front.castShadow = true;
      front.receiveShadow = true;
      handleObj.castShadow = true;
      handleObj.receiveShadow = true;
      foundationObj.castShadow = true;
      foundationObj.receiveShadow = true;

      return new THREE.Group()
        .add(foundationObj)
        .add(sideRight)
        .add(sideLeft)
        .add(front)
        .add(back)
        .add(handleObj);
    }
  }
  //Fireplace class
  class Fireplace {
    width;
    height;

    constructor(width, height) {
      this.width = width;
      this.height = height;
    }

    //TODO: Add bars
    getObject() {
      const foundationHeight = this.height/3;
      const foundationSide = new THREE.BoxBufferGeometry(this.width/6, foundationHeight, this.width);
      const foundationBack = new THREE.BoxBufferGeometry(this.width, foundationHeight, this.width/6);
      const foundationBottom = new THREE.BoxBufferGeometry(this.width - 2* this.width/6, foundationHeight/6, this.width - this.width/6);

      let connector = new THREE.ConeGeometry(this.width * Math.sqrt(2)/2, this.height/3, 4);
      const chimney = new THREE.BoxBufferGeometry(this.width/2, this.height/3 + 0.3, 0.4);

      const textureLoader = new THREE.TextureLoader();
      const brickTexture = textureLoader.load("/materials/fireplace.jpg");
      brickTexture.wrapS = THREE.RepeatWrapping;
      brickTexture.wrapT = THREE.RepeatWrapping;
      brickTexture.repeat.set(1,2);
      const material = new THREE.MeshPhongMaterial({ map: brickTexture});

      const foundationLeft = new THREE.Mesh(foundationSide, material);
      const foundationRight = new THREE.Mesh(foundationSide, material);
      const foundationBackObj = new THREE.Mesh(foundationBack, material);
      const foundationBottomObj = new THREE.Mesh(foundationBottom, material);

      const connectorObj = new THREE.Mesh(connector, material);
      const chimneyObj = new THREE.Mesh(chimney, material);

      foundationLeft.castShadow = true;
      foundationLeft.receiveShadow = true;
      foundationRight.castShadow = true;
      foundationRight.receiveShadow = true;
      foundationBackObj.castShadow = true;
      foundationBackObj.receiveShadow = true;
      foundationBottomObj.castShadow = true;
      foundationBottomObj.receiveShadow = true;

      connectorObj.castShadow = true;
      connectorObj.receiveShadow = true;
      chimneyObj.castShadow = true;
      chimneyObj.receiveShadow = true;

      foundationLeft.position.set(-this.width/2 + this.width/12,-this.height/3,0);
      foundationRight.position.set(this.width/2 - this.width/12,-this.height/3,0);
      foundationBackObj.position.set(0,-this.height/3, this.width/2 - this.width/6);
      foundationBottomObj.position.set(0,-this.height/2 + foundationHeight/12,0);
      chimneyObj.position.set(0,this.height/3- 0.3,0);
      connectorObj.rotateY(Math.PI/4);
      return new THREE.Group()
        .add(foundationLeft)
        .add(foundationRight)
        .add(foundationBackObj)
        .add(foundationBottomObj)
        .add(connectorObj)
        .add(chimneyObj);
    }
  }

  //Floor related class
  class Flooring {
    width;
    height;
    depth;
    image;

    constructor(width, height, depth, image) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.image = image;
    }
    getObject() {
      const flooring = new THREE.BoxBufferGeometry(this.width, this.height, this.depth);

      const textureLoader = new THREE.TextureLoader();
      const flooringTexture = textureLoader.load(this.image);
      flooringTexture.wrapS = THREE.RepeatWrapping;
      flooringTexture.wrapT = THREE.RepeatWrapping;
      flooringTexture.repeat.set(3,4);
      const flooringMaterial = new THREE.MeshPhongMaterial({map: flooringTexture});

      const flooringObj = new THREE.Mesh(flooring, flooringMaterial);
      flooringObj.castShadow = true;
      flooringObj.receiveShadow = true;

      return flooringObj;
    }
  }

  //Furnace class
  class Furnace {
    width;
    height;
    depth;
    levels;
    constructor(width, height, depth, levels) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.levels = levels;
    }

    //TODO: kotloni, and a handle
    getObject() {
      const heightLongSide = this.height - 2*this.height/5;
      const widthLongSide = this.width/8;
      const heightShortSide = this.height/5;
      const widthShortSide = this.width;
      const heightInside = this.height - heightShortSide*2;

      const widthGeometry = new THREE.BoxBufferGeometry(widthShortSide, heightShortSide, this.depth);
      const heightGeometry = new THREE.BoxBufferGeometry(widthLongSide, heightLongSide, this.depth);
      const visibleGeometry = new THREE.BoxBufferGeometry(this.width - 2 * widthLongSide, heightLongSide, 0.01);
      const back = new THREE.BoxBufferGeometry(this.width, this.height + 0.1, 0.05);
      const buttonGeometry = new THREE.TorusBufferGeometry(0.01, 0.03, 6, 6, 6);

      const textureLoader = new THREE.TextureLoader();
      const furnaceMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
      const sidesMaterial = new THREE.MeshPhongMaterial({color: 0xC0C0C0, shininess: 100, specular: 0xffffff});
      const glassMaterial = new THREE.MeshPhongMaterial({color: 0xC7E3E1, shininess: 100, specular: 'cyan', transparent: true, opacity: 0.2})

      const topObj = new THREE.Mesh(widthGeometry, furnaceMaterial);
      const bottomObj = topObj.clone();
      const leftObj = new THREE.Mesh(heightGeometry, sidesMaterial);
      const rightObj = leftObj.clone();
      const glassObj = new THREE.Mesh(visibleGeometry, glassMaterial);
      const backObj = new THREE.Mesh(back, furnaceMaterial);
      const button1Obj = new THREE.Mesh(buttonGeometry,sidesMaterial);
      const button2Obj = button1Obj.clone();
      const button3Obj = button1Obj.clone();
      const button4Obj = button1Obj.clone();

      button1Obj.position.set(-this.width/2 + 0.1, this.height/2 - 0.1, this.depth/2);
      button2Obj.position.set(-this.width/2 + 0.2, this.height/2 - 0.1, this.depth/2);
      button3Obj.position.set(-this.width/2 + 0.3, this.height/2 - 0.1, this.depth/2);
      button4Obj.position.set(-this.width/2 + 0.4, this.height/2 - 0.1, this.depth/2);


      topObj.position.set(0, this.height/2 - heightShortSide/2, 0);
      bottomObj.position.set(0, -this.height/2 + heightShortSide/2, 0);
      leftObj.position.set(-this.width/2 + widthLongSide/2,0,0);
      rightObj.position.set(this.width/2 - widthLongSide/2,0,0);
      backObj.position.set(0,0.1,-this.depth/2 + 0.05);
      glassObj.position.set(0,0, this.depth/2);

      topObj.castShadow = true;
      topObj.receiveShadow = true;
      bottomObj.receiveShadow = true;
      bottomObj.castShadow = true;
      leftObj.receiveShadow = true;
      leftObj.castShadow = true;
      rightObj.castShadow = true;
      rightObj.receiveShadow = true;
      backObj.castShadow = true;
      backObj.receiveShadow = true;
      glassObj.receiveShadow = true;
      glassObj.castShadow = true;


      const furnaceGroup = new THREE.Group()
        .add(topObj)
        .add(bottomObj)
        .add(leftObj)
        .add(rightObj)
        .add(backObj)
        .add(glassObj)
        .add(button1Obj)
        .add(button2Obj)
        .add(button3Obj)
        .add(button4Obj);

      for (let i = 0; i < 2; i++) {
        const sheet = new FurnaceSheet(this.width - 2*widthLongSide, this.depth, 6,6).getObject();
        sheet.position.set(0, this.height/2 - (heightInside/2) * (i + 1), 0);
        furnaceGroup.add(sheet);
      }

      return furnaceGroup;
    }
  }

  //Toilet class
  class Toilet {

    static getObject() {
      const foundation = new THREE.BoxBufferGeometry(0.3, 0.5, 0.5);
      const seatFoundation = new THREE.BoxBufferGeometry(0.5, 0.1, 0.5);
      const seat = new THREE.BoxBufferGeometry(0.5, 0.05, 0.3);
      const upper = new THREE.BoxBufferGeometry(0.5, 0.5, 0.15);

      const height = 0.95;
      const depth = 0.6;
      const textureLoader = new THREE.TextureLoader();
      const toiletTexture = textureLoader.load("https://gruppoconcorde-cdn.thron.com/delivery/public/image/gruppoconcorde/ec3a471e-2a39-4bc4-bea1-6b005c49b7af/sccw3m/std/409x0/AtlasConcorde_BoostNatural_Kaolin_50x120_Matte_A64V_3DTexture.jpg?format=WEBP&");
      const fayansMaterial = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        map: toiletTexture
      });

      const foundationObj = new THREE.Mesh(foundation, fayansMaterial);
      const seatFoundationObj = new THREE.Mesh(seatFoundation, fayansMaterial);
      const seatObj = new THREE.Mesh(seat, new THREE.MeshPhongMaterial({color: 0x666666, map: toiletTexture}));
      const upperObj = new THREE.Mesh(upper, fayansMaterial);

      foundationObj.position.set(0, -height/2,0);
      seatFoundationObj.position.set(0, -height/2 + 0.3, 0);
      seatObj.position.set(0,-height/2 + 0.375, -0.1);
      upperObj.position.set(0, height/2 - 0.4, depth/2 - 0.1);

      foundationObj.receiveShadow = true;
      foundationObj.castShadow = true;
      seatFoundationObj.receiveShadow = true;
      seatFoundationObj.castShadow = true;
      seatObj.receiveShadow = true;
      seatObj.castShadow = true;
      upperObj.receiveShadow = true;
      upperObj.castShadow = true;

      return new THREE.Group()
        .add(foundationObj)
        .add(seatFoundationObj)
        .add(seatObj)
        .add(upperObj);

    }
  }

  //Window class
  class WindowPanel {
    numberOfPanels;
    widthPanel;
    heightPanel;

    constructor(widthPanel, heightPanel, numberOfPanels) {
      this.widthPanel = widthPanel;
      this.heightPanel = heightPanel;
      this.numberOfPanels = numberOfPanels;
    }

    getObject() {
      const outerFrameTop = new THREE.BoxBufferGeometry(this.widthPanel + 0.1, 0.1, 0.22);
      const outerFrameBottom = new THREE.BoxBufferGeometry(this.widthPanel + 0.1, 0.1, 0.22);
      const outerFrameLeft = new THREE.BoxBufferGeometry(0.1, this.heightPanel, 0.22);
      const outerFrameRight = new THREE.BoxBufferGeometry(0.1, this.heightPanel, 0.22);

      const glass = new THREE.BoxBufferGeometry(this.widthPanel, this.heightPanel, 0.1);

      const glassMaterial = new THREE.MeshPhongMaterial({color: 'cyan', transparent: true, opacity: 0.3});
      const woodTexture = new THREE.TextureLoader();
      const frameMaterial = new THREE.MeshPhongMaterial({
        color: 0xBA7c45,
        transparent: true,
        map: woodTexture.load("/materials/wood.jpg")
      });

      const frameTopObj = new THREE.Mesh(outerFrameTop, frameMaterial);
      const frameBottomObj = new THREE.Mesh(outerFrameBottom, frameMaterial);
      const frameLeftObj = new THREE.Mesh(outerFrameLeft, frameMaterial);
      const frameRightObj = new THREE.Mesh(outerFrameRight, frameMaterial);

      frameTopObj.position.set(0, this.heightPanel / 2, 0);
      frameBottomObj.position.set(0, -this.heightPanel / 2, 0);
      frameLeftObj.position.set(-this.widthPanel / 2, 0, 0);
      frameRightObj.position.set(this.widthPanel / 2, 0, 0);

      const glassObj = new THREE.Mesh(glass, glassMaterial);
      const Group = new THREE.Group().add(frameTopObj).add(frameBottomObj).add(frameLeftObj).add(frameRightObj).add(glassObj);

      for (let i = 0; i < this.numberOfPanels - 1; i++) {
        const helperHorizontal = new THREE.BoxBufferGeometry(0.1, this.heightPanel, 0.22);
        const helperHorizontalObj = new THREE.Mesh(helperHorizontal, frameMaterial);
        helperHorizontalObj.position.set(-this.widthPanel/2 + this.widthPanel/this.numberOfPanels * (i + 1), 0, 0);
        helperHorizontalObj.castShadow = true;
        helperHorizontalObj.receiveShadow = true;
        Group.add(helperHorizontalObj);
      }

      return Group;
    }
  }

  //Table class
  class Table {
    width;
    color;
    depth;
    hasCloth;

    constructor(width, depth, hasCloth = true, color = 0xffffff) {
      this.width = width;
      this.depth = depth;
      this.color = color;
      this.hasCloth = hasCloth;
    }

    getObject() {
      const foundation = new THREE.BoxBufferGeometry(this.width, 0.05, this.depth);
      const leg = new THREE.BoxBufferGeometry(0.05, 0.7, 0.05);
      const tableCloth = new THREE.BoxBufferGeometry(this.width, 0.001, this.depth);
      const tableClothSideLong = new THREE.BoxBufferGeometry(this.width, 0.2, 0.001);
      const tableClothSideShort = new THREE.BoxBufferGeometry(0.001, 0.2, this.depth);

      const textureLoader = new THREE.TextureLoader();
      const woodMaterial = new THREE.MeshPhongMaterial({map: textureLoader.load("/materials/wood.jpg")});

      const foundationObj = new THREE.Mesh(foundation, woodMaterial);
      const bottomLeftLeg = new THREE.Mesh(leg, woodMaterial);
      const bottomRightLeg = new THREE.Mesh(leg, woodMaterial);
      const topLeftLeg = new THREE.Mesh(leg, woodMaterial);
      const topRightLeg = new THREE.Mesh(leg, woodMaterial);

      const tableGroup = new THREE.Group();

      if (this.hasCloth) {
        const clothMaterial = new THREE.MeshStandardMaterial({
          color: 0xff12412,
          map: textureLoader.load("/materials/blanket.jpg")
        });
        const tableClothObj = new THREE.Mesh(tableCloth, clothMaterial);
        const tableClothRightSideLong = new THREE.Mesh(tableClothSideLong, clothMaterial);
        const tableClothLeftSideLong = new THREE.Mesh(tableClothSideLong, clothMaterial);
        const tableClothTopShort = new THREE.Mesh(tableClothSideShort, clothMaterial);
        const tableClothBottomShort = new THREE.Mesh(tableClothSideShort, clothMaterial);

        tableClothObj.position.set(0, 0.0251, 0);
        tableClothRightSideLong.position.set(0, -0.075, -this.depth / 2);
        tableClothLeftSideLong.position.set(0, -0.075, this.depth / 2);
        tableClothTopShort.position.set(this.width / 2, -0.075, 0);
        tableClothBottomShort.position.set(-this.width / 2, -0.075, 0);

        tableClothObj.castShadow = true;
        tableClothObj.receiveShadow = true;
        tableClothRightSideLong.castShadow = true;
        tableClothRightSideLong.receiveShadow = true;
        tableClothLeftSideLong.castShadow = true;
        tableClothLeftSideLong.receiveShadow = true;
        tableClothTopShort.castShadow = true;
        tableClothTopShort.receiveShadow = true;
        tableClothBottomShort.castShadow = true;
        tableClothBottomShort.receiveShadow = true;

        tableGroup
          .add(tableClothObj)
          .add(tableClothRightSideLong)
          .add(tableClothLeftSideLong)
          .add(tableClothTopShort)
          .add(tableClothBottomShort);
      }

      bottomLeftLeg.position.set(this.width / 2 - 0.05, -0.35, this.depth / 2 - 0.05);
      bottomRightLeg.position.set(this.width / 2 - 0.05, -0.35, -this.depth / 2 + 0.05);
      topLeftLeg.position.set(-this.width / 2 + 0.05, -0.35, this.depth / 2 - 0.05);
      topRightLeg.position.set(-this.width / 2 + 0.05, -0.35, -this.depth / 2 + 0.05);

      bottomLeftLeg.castShadow = true;
      bottomLeftLeg.receiveShadow = true;
      bottomRightLeg.castShadow = true;
      bottomRightLeg.receiveShadow = true;
      topLeftLeg.castShadow = true;
      topLeftLeg.receiveShadow = true;
      topRightLeg.castShadow = true;
      topRightLeg.receiveShadow = true;

      return tableGroup
        .add(foundationObj)
        .add(bottomLeftLeg)
        .add(bottomRightLeg)
        .add(topLeftLeg)
        .add(topRightLeg);
    }
  }

  //Sink class
  class Sink {
    width;
    height;
    depth;

    constructor(width, height, depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
    }

    getObject() {
      const pathTube = new THREE.CurvePath();
      pathTube.curves.push(new THREE.Curve());
      const sinkFoundation = new THREE.SphereBufferGeometry(0.2, 64, 32, 0, 6.28, 1.64619455048105, 1.80327418316054);

      const textureLoader = new THREE.TextureLoader();
      const kaolin = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        map: textureLoader.load("https://gruppoconcorde-cdn.thron.com/delivery/public/image/gruppoconcorde/ec3a471e-2a39-4bc4-bea1-6b005c49b7af/sccw3m/std/409x0/AtlasConcorde_BoostNatural_Kaolin_50x120_Matte_A64V_3DTexture.jpg?format=WEBP&")
      })
      kaolin.side = THREE.DoubleSide;
      const sinkObj = new THREE.Mesh(sinkFoundation, kaolin);
      sinkObj.position.set(0, this.height / 2 + 0.2, 0);
      const tubeMaterial = new THREE.MeshPhongMaterial({color: 0x333333})
      const cylinderFoundation = new THREE.CylinderBufferGeometry(0.03, 0.03, 0.25);
      const smallerCylinder = new THREE.CylinderBufferGeometry(0.01, 0.01, 0.1);

      const smallerCylinderObj  = new THREE.Mesh(smallerCylinder, tubeMaterial);
      const foundationObj = new THREE.Mesh(cylinderFoundation, tubeMaterial);

      foundationObj.position.set(-0.2,this.height/2 + 0.125, 0.15);
      smallerCylinderObj.position.set(-0.15,this.height/2 + 0.2, 0.1);
      smallerCylinderObj.rotateX(Math.PI /2);
      smallerCylinderObj.rotateZ(Math.PI /4);


      return new THREE.Group()
        .add(sinkObj)
        .add(new Cupboard(this.width, this.height, this.depth, 1, 2, true).getObject())
        .add(foundationObj)
        .add(smallerCylinderObj);
    }
  }

  //Painting class
  class Painting {
    width;
    height;
    image;
    frameWidth;
    //image accepts path as string to the image to be displayed
    constructor(width, height, frameWidth, image) {
      this.width = width;
      this.height = height;
      this.image = image;
      this.frameWidth = frameWidth;
    }

    getObject() {
      const frameWidth = new THREE.BoxBufferGeometry(this.width, this.frameWidth, this.frameWidth);
      const frameHeight = new THREE.BoxBufferGeometry(this.frameWidth, this.height, this.frameWidth);
      const plate = new THREE.BoxBufferGeometry(this.width, this.height, 0.002);

      const textureLoader = new THREE.TextureLoader();
      const woodMaterial = new THREE.MeshPhongMaterial({color: 0x855E42, map: textureLoader.load("/materials/wood.jpg") });
      const paintingMaterial = new THREE.MeshPhongMaterial({map: textureLoader.load(this.image)});

      const topFrameWidth = new THREE.Mesh(frameWidth, woodMaterial);
      const bottomFrameWidth = new THREE.Mesh(frameWidth, woodMaterial);
      const leftFrameHeight = new THREE.Mesh(frameHeight, woodMaterial);
      const rightFrameHeight = new THREE.Mesh(frameHeight, woodMaterial);
      const painting = new THREE.Mesh(plate, paintingMaterial);

      topFrameWidth.position.set(0, this.height/2, 0.001);
      bottomFrameWidth.position.set(0, -this.height/2, 0.001);
      leftFrameHeight.position.set(-this.width/2,0, 0.001);
      rightFrameHeight.position.set(this.width/2,0, 0.001);

      topFrameWidth.castShadow = true;
      topFrameWidth.receiveShadow = true;
      bottomFrameWidth.castShadow = true;
      bottomFrameWidth.receiveShadow = true;
      leftFrameHeight.castShadow = true;
      leftFrameHeight.receiveShadow = true;
      rightFrameHeight.castShadow = true;
      rightFrameHeight.receiveShadow = true;
      painting.castShadow = true;
      painting.receiveShadow = true;

      return new THREE.Group()
        .add(topFrameWidth)
        .add(bottomFrameWidth)
        .add(leftFrameHeight)
        .add(rightFrameHeight)
        .add(painting);
    }
  }

  //Monitor/TV class with Mouse and Keyboard
  class Monitor {
    inches;
    image;
    isTV;

    constructor(inches, isTV = false, image = "/materials/default-monitor.jpg") {
      this.inches = inches;
      this.isTV = isTV;
      this.image = image;
    }

    getMouse(frameMaterial) {
      const mouse = new THREE.BoxBufferGeometry(0.05, 0.02, 0.1);
      const button = new THREE.BoxBufferGeometry(0.02, 0.01, 0.02);

      const mouseObj = new THREE.Mesh(mouse, frameMaterial);
      const leftButton = new THREE.Mesh(button, new THREE.MeshPhongMaterial({color: 0x777777}));
      const rightButton = leftButton.clone();
      leftButton.position.set(-0.015, 0.01, -0.03);
      rightButton.position.set(0.015, 0.01, -0.03);

      leftButton.castShadow = true;
      leftButton.receiveShadow = true;
      rightButton.castShadow = true;
      rightButton.receiveShadow = true;
      mouseObj.castShadow = true;
      mouseObj.receiveShadow = true;

      return  new THREE.Group().add(mouseObj).add(leftButton).add(rightButton);
    }

    getKeyboard(frameMaterial) {
      const widthKeyboard = 0.3;
      const heightKeyboard = 0.02;
      const depthKeyboard = 0.1;

      const keysPerRow = 20;
      const keysPerColumn = 5;
      const widthKey = widthKeyboard / keysPerRow - 0.0005;
      const depthKey = depthKeyboard / keysPerColumn - 0.0005;

      const keyboardFoundation = new THREE.BoxBufferGeometry(widthKeyboard, heightKeyboard, depthKeyboard);
      const keyboardObj = new THREE.Mesh(keyboardFoundation, frameMaterial);
      keyboardObj.castShadow = true;
      keyboardObj.receiveShadow = true;
      const keyboardGroup = new THREE.Group().add(keyboardObj);

      for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 20; j++) {
          const color = Math.floor(Math.random()*16777215).toString(16);
          const key = new THREE.BoxBufferGeometry(widthKey, 0.02, depthKey);
          const keyObj = new THREE.Mesh(key, new THREE.MeshPhongMaterial({color: "#"+color}));
          keyObj.position.set(-widthKeyboard/2 + (widthKey * (j + 1)), 0.01, -depthKeyboard/2 + (depthKey * (i + 1)));
          keyObj.castShadow = true;
          keyObj.receiveShadow = true;
          keyboardGroup.add(keyObj);
        }
      }

      return keyboardGroup;
    }

    getObject() {
      const widthGetter = 0.872;
      const heightGetter = 0.49;
      var width = this.inches * widthGetter;
      var height = this.inches * heightGetter;

      const monitorScreen = new THREE.BoxBufferGeometry(width, height, 0.001);
      const monitorBack = new THREE.BoxBufferGeometry(width, height, 0.01);
      const widthFrame = new THREE.BoxBufferGeometry(width, 0.01, 0.01);
      const heightFrame = new THREE.BoxBufferGeometry(0.01, height, 0.01);


      const textureLoader = new THREE.TextureLoader();
      const texture = textureLoader.load(this.image);
      const screenMaterial = new THREE.MeshPhongMaterial({map: texture});
      const frameMaterial = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        map: textureLoader.load("https://img.freepik.com/premium-photo/texture-black-carbon-fiber_28943-725.jpg")
      });

      const screenObj = new THREE.Mesh(monitorScreen, screenMaterial);
      const backObj = new THREE.Mesh(monitorBack, frameMaterial);
      const topFrame = new THREE.Mesh(widthFrame, frameMaterial);
      const bottomFrame = topFrame.clone();
      const leftFrame = new THREE.Mesh(heightFrame, frameMaterial);
      const rightFrame = leftFrame.clone();

      topFrame.position.set(0, height / 2, 0.01);
      bottomFrame.position.set(0, -height / 2, 0.01);
      leftFrame.position.set(-width / 2, 0, 0.01);
      rightFrame.position.set(width / 2, 0, 0.01);

      backObj.position.set(0, 0, -0.001);
      screenObj.position.set(0, 0, 0.005);

      topFrame.castShadow = true;
      topFrame.receiveShadow = true;
      bottomFrame.castShadow = true;
      bottomFrame.receiveShadow = true;
      leftFrame.castShadow = true;
      leftFrame.receiveShadow = true;
      rightFrame.castShadow = true;
      rightFrame.receiveShadow = true;
      backObj.castShadow = true;
      backObj.receiveShadow = true;
      screenObj.castShadow = true;
      screenObj.receiveShadow = true;

      const monitorGroup = new THREE.Group()
        .add(screenObj)
        .add(topFrame)
        .add(bottomFrame)
        .add(leftFrame)
        .add(rightFrame)
        .add(backObj);

      if (!this.isTV) {
        const foundation = new THREE.BoxBufferGeometry(width / 3, 0.03, width / 3);
        const connector = new THREE.BoxBufferGeometry(width / 5, height / 3, 0.01);
        const foundationObj = new THREE.Mesh(foundation, frameMaterial);
        const connectorObj = new THREE.Mesh(connector, frameMaterial);
        foundationObj.position.set(0, -height / 2 - height / 3, 0);
        connectorObj.position.set(0, -height / 2 - (height / 6), 0);

        foundationObj.castShadow = true;
        foundationObj.receiveShadow = true;
        connectorObj.castShadow = true;
        connectorObj.receiveShadow = true;

        const mouseGroup = this.getMouse(frameMaterial);
        mouseGroup.position.set( width/2 + width/3,-height/2 - height/3, width/2);

        const keyboardGroup = this.getKeyboard(frameMaterial);
        keyboardGroup.position.set(-width/2 + width/3, -height/2 - height/3, width/2);

        monitorGroup
          .add(foundationObj)
          .add(connectorObj)
          .add(mouseGroup)
          .add(keyboardGroup);
      } else {
        const leg = new THREE.BoxBufferGeometry(0.1, 0.05, 0.1);
        const leftLeg = new THREE.Mesh(leg, frameMaterial);
        const rightLeg = leftLeg.clone();

        leftLeg.position.set(-width / 2 + width / 4, -height / 2 - 0.025, 0);
        rightLeg.position.set(width / 2 - width / 4, -height / 2 - 0.025, 0);

        leftLeg.castShadow = true;
        leftLeg.receiveShadow = true;
        rightLeg.castShadow = true;
        rightLeg.receiveShadow = true;

        monitorGroup
          .add(leftLeg)
          .add(rightLeg);
      }
      return monitorGroup;
    }
  }

  //Furnace sheet class
  class FurnaceSheet {
    width;
    depth;
    numWidth;
    numDepth;

    constructor(width, depth, numWidth, numDepth) {
      this.width = width;
      this.depth = depth;
      this.numWidth = numWidth;
      this.numDepth = numDepth;
    }

    getObject() {
      const widthSide = new THREE.BoxBufferGeometry(this.width, 0.005, 0.005);
      const depthSide = new THREE.BoxBufferGeometry(0.005, 0.005, this.depth);

      const sheetMaterial = new THREE.MeshPhongMaterial({color: 0x111111});
      const sheetsGroup = new THREE.Group();

      const frameLeft = new THREE.Mesh(depthSide, sheetMaterial);
      const frameRight = frameLeft.clone();
      const frameBack = new THREE.Mesh(widthSide, sheetMaterial);
      const frameFront = frameBack.clone();

      for (let i = 0; i < this.numWidth; i++) {
        const obj = frameFront.clone();
        obj.position.set(0, 0, this.depth/2 - (this.depth/this.numDepth) * (i + 1) - (this.depth/this.numDepth)/2 + 0.05);
        obj.castShadow = true;
        obj.receiveShadow = true;
        sheetsGroup.add(obj);
      }

      for (let i = 0; i < this.numDepth; i++) {
        const obj = frameLeft.clone();
        obj.position.set(-this.width/2 + (this.width/this.numWidth) * (i + 1) + (this.width/this.numWidth)/2 - 0.05, 0,0 );
        obj.castShadow = true;
        obj.receiveShadow = true;
        sheetsGroup.add(obj);
      }
      frameBack.position.set(0,0,-this.depth/2);
      frameFront.position.set(0,0, this.depth/2);
      frameLeft.position.set(-this.width/2,0,0);
      frameRight.position.set(this.width/2,0,0);

      frameLeft.castShadow = true;
      frameLeft.receiveShadow = true;
      frameBack.receiveShadow = true;
      frameBack.castShadow = true;
      frameFront.receiveShadow = true;
      frameFront.castShadow = true;
      frameRight.castShadow = true;
      frameRight.receiveShadow = true;

      return sheetsGroup
        .add(frameLeft)
        .add(frameRight)
        .add(frameFront)
        .add(frameBack);
    }
  }

  //Desk class
  class Desk {
    width;
    depth;
    numberDrawers;

    constructor(width, depth, numberDrawers) {
      this.width = width;
      this.depth = depth;
      this.numberDrawers = numberDrawers;
    }

    getObject() {
      const foundation = new THREE.BoxBufferGeometry(this.width, 0.03, this.depth);
      const sideShort = new THREE.BoxBufferGeometry(0.03, 0.7, this.depth);
      const sideLong = new THREE.BoxBufferGeometry(this.width, 0.7, 0.03);

      const textureLoader = new THREE.TextureLoader();
      const deskMaterial = new THREE.MeshPhongMaterial({map: textureLoader.load("/materials/dark-wood.jpg")});

      const foundationObj = new THREE.Mesh(foundation, deskMaterial);
      const sideShortLeft = new THREE.Mesh(sideShort, deskMaterial);
      const sideShortRight = sideShortLeft.clone();
      const insideShort = sideShortLeft.clone();
      const sideLongObj = new THREE.Mesh(sideLong, deskMaterial);

      sideShortLeft.position.set(-this.width/2 + 0.03, -0.35,0);
      sideShortRight.position.set(this.width/2 - 0.03, -0.35,0);
      sideLongObj.position.set(0, -0.35,this.depth/2 - 0.03);
      insideShort.position.set((-this.width/2)+(this.width/3 * 2) - 0.1, -0.35,0);

      sideShortLeft.castShadow = true;
      sideShortLeft.receiveShadow = true;
      sideShortRight.castShadow = true;
      sideShortRight.receiveShadow = true;
      sideLongObj.castShadow = true;
      sideLongObj.receiveShadow = true;
      insideShort.castShadow = true;
      insideShort.receiveShadow = true;

      const deskGroup = new THREE.Group()
        .add(foundationObj)
        .add(sideShortRight)
        .add(sideShortLeft)
        .add(insideShort)
        .add(sideLongObj);

      for (let i = 0; i < this.numberDrawers; i++) {
        const drawer = new Drawer(this.width/3, 0.8/this.numberDrawers, this.depth);
        const drawerObj = drawer.getObject();
        drawerObj.position.set((this.width/3) - 0.05, (-0.5/this.numberDrawers) * (i + 1), -0.05);
        deskGroup.add(drawerObj);
      }
      return deskGroup;
    }
  }

  //Cupboard class
  class Cupboard {
    width;
    height;
    depth;
    heightLevels;
    widthLevels;
    hasDrawers;
    numberOfDrawersPerLevel;
    colorFoundation;
    colorDrawers;

    constructor(width, height, depth, heightLevels, widthLevels,
                hasDrawers = false,
                numberOfDrawersPerLevel = 0,
                colorFoundation = 0xffffff,
                colorDrawers = 0xffffff) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.heightLevels = heightLevels;
      this.widthLevels = widthLevels;
      this.hasDrawers = hasDrawers;
      this.numberOfDrawersPerLevel = numberOfDrawersPerLevel;
      this.colorFoundation = colorFoundation;
      this.colorDrawers = colorDrawers;
    }
    getDrawers() {
      const drawerGroup = new THREE.Group();
      for (let i = 0; i < this.heightLevels; i++) {
        for (let j = 0; j < this.widthLevels; j++) {
          const drawer = new Drawer(
            this.width/this.widthLevels,
            this.height/ this.heightLevels,
            this.depth - 0.1)
            .getObject();

          drawer.position.set(
            this.width/2 - (this.width/this.widthLevels) * (j + 1) + (this.width/this.widthLevels) / 2,
            this.height/2 - (this.height/ this.heightLevels) * (i + 1) + (this.height/ this.heightLevels) /2,
            0);
          drawerGroup.add(drawer);
        }
      }
      return drawerGroup;
    }

    getObject() {
      const widthPlate = new THREE.BoxBufferGeometry(this.width, 0.03, this.depth);
      const heightPlate = new THREE.BoxBufferGeometry(0.03, this.height, this.depth);

      const textureLoader = new THREE.TextureLoader();
      const woodTexture = textureLoader.load("/materials/dark-wood.jpg");
      const frameMaterial = new THREE.MeshPhongMaterial({color: this.colorFoundation, map: woodTexture});

      const topPlate = new THREE.Mesh(widthPlate, frameMaterial);
      const bottomPlate = topPlate.clone();
      const leftPlate = new THREE.Mesh(heightPlate, frameMaterial);
      const rightPlate = leftPlate.clone();

      const cupboardGroup = new THREE.Group();

      for (let i = 0; i < this.heightLevels - 1; i++) {
        const middleWidthPlate = new THREE.Mesh(widthPlate, frameMaterial);
        middleWidthPlate.position.set(0, (this.height / 2) - (this.height / this.heightLevels) * (i + 1), 0);
        middleWidthPlate.castShadow = true;
        middleWidthPlate.receiveShadow = true;
        cupboardGroup.add(middleWidthPlate);
      }

      for (let i = 0; i < this.widthLevels - 1; i++) {
        const middleHeightPlate = new THREE.Mesh(heightPlate, frameMaterial);
        middleHeightPlate.position.set((this.width / 2) - (this.width / this.widthLevels) * (i + 1), 0);
        middleHeightPlate.castShadow = true;
        middleHeightPlate.receiveShadow = true;
        cupboardGroup.add(middleHeightPlate);
      }
      topPlate.position.set(0, this.height / 2, 0);
      bottomPlate.position.set(0, -this.height / 2, 0);
      leftPlate.position.set(-this.width / 2, 0, 0);
      rightPlate.position.set(this.width / 2, 0, 0);

      topPlate.castShadow = true;
      topPlate.receiveShadow = true;
      bottomPlate.castShadow = true;
      bottomPlate.receiveShadow = true;
      leftPlate.castShadow = true;
      leftPlate.receiveShadow = true;
      rightPlate.castShadow = true;
      rightPlate.receiveShadow = true;

      if(this.hasDrawers) {
        cupboardGroup.add(this.getDrawers());
      }
      return cupboardGroup
        .add(topPlate)
        .add(bottomPlate)
        .add(leftPlate)
        .add(rightPlate);
    }
  }

  //Chair class
  class Chair {
    colorCushion;
    constructor(colorCushion) {
      this.colorCushion = colorCushion;
    }

    getObject() {
      const seat = new THREE.BoxBufferGeometry(0.4, 0.1, 0.4);
      const leg = new THREE.BoxBufferGeometry(0.05, 0.5,0.05);
      const backLeg = new THREE.BoxBufferGeometry(0.05, 1, 0.05);
      const cushion = new THREE.BoxBufferGeometry(0.36, 0.05, 0.36);
      const bridgeLegs = new THREE.BoxBufferGeometry(0.25, 0.05, 0.05);

      const textureLoader = new THREE.TextureLoader();
      const chairMaterial = new THREE.MeshPhongMaterial({map: textureLoader.load("/materials/wood.jpg")});
      const cushionMaterial = new THREE.MeshPhongMaterial({map: textureLoader.load("/materials/blanket.jpg"), color: this.colorCushion});

      const seatObj = new THREE.Mesh(seat, chairMaterial);
      const frontLeftLeg = new THREE.Mesh(leg, chairMaterial);
      const frontRightLeg = new THREE.Mesh(leg, chairMaterial);
      const backLeftLeg = new THREE.Mesh(backLeg, chairMaterial);
      const backRightLeg = new THREE.Mesh(backLeg, chairMaterial);
      const leg1Bridge = new THREE.Mesh(bridgeLegs, chairMaterial);
      const leg2Bridge = new THREE.Mesh(bridgeLegs, chairMaterial);
      const cushionObj = new THREE.Mesh(cushion, cushionMaterial);

      frontLeftLeg.position.set(-0.15, -0.2, 0.15);
      frontRightLeg.position.set(0.15, -0.2, 0.15);
      backLeftLeg.position.set(0.15, 0.05, -0.15);
      backRightLeg.position.set(-0.15, 0.05, -0.15);
      leg1Bridge.position.set(0, 0.3, -0.15);
      leg2Bridge.position.set(0, 0.5, -0.15);
      cushionObj.position.set(0, 0.05, 0);

      frontLeftLeg.castShadow = true;
      frontLeftLeg.receiveShadow = true;
      frontRightLeg.castShadow = true;
      frontRightLeg.receiveShadow = true;
      backLeftLeg.castShadow = true;
      backLeftLeg.receiveShadow = true;
      backRightLeg.castShadow = true;
      backRightLeg.receiveShadow = true;
      leg1Bridge.castShadow = true;
      leg1Bridge.receiveShadow = true;
      leg2Bridge.castShadow = true;
      leg2Bridge.receiveShadow = true;
      cushionObj.castShadow = true;
      cushionObj.receiveShadow = true;

      return  new THREE.Group().add(seatObj).add(frontLeftLeg).add(frontRightLeg).add(backRightLeg).add(backLeftLeg).add(cushionObj).add(leg1Bridge).add(leg2Bridge);
    }
  }

  //Bed class
  class Bed {
    width;
    height;
    panels;
    color;
    pillowColor;
    blanketColor;

    constructor(width, height, panels, color, pillowColor, blanketColor) {
      this.width = width;
      this.height = height;
      this.panels = panels;
      this.color = color;
      this.pillowColor = pillowColor;
      this.blanketColor = blanketColor;
    }

    getPillow(geometry, material, index) {
      const pillowObj = new THREE.Mesh(geometry, material);
      pillowObj.rotateX(Math.PI / 2);
      pillowObj.rotateZ(Math.PI / 2);
      pillowObj.position.y = 0.21;
      pillowObj.position.x = this.width / 2 - 0.1;
      pillowObj.position.z = (-this.height / 2 + (this.height / this.panels * (index + 1))) - 0.6;

      return pillowObj;
    }

    getBlanket(geometry, material, index) {
      const blanketObj = new THREE.Mesh(geometry, material);
      blanketObj.position.set(-this.width/2 + 0.3, 0.1, -this.height / 2 + (this.height / this.panels * (index + 1)) - 0.5)
      return blanketObj;
    }


    getObject() {
      const foundation = new THREE.BoxBufferGeometry(this.width, this.height, 0.1);
      const leg = new THREE.BoxBufferGeometry(0.1, 0.2, 0.1);
      const pillow = new THREE.Shape();

      const extrudeSettings = {
        steps: 3,
        depth: 0.1,
        bevelEnabled: true,
        bevelThickness: 0.05,
        bevelSize: 0.1,
        bevelOffset: 0,
        bevelSegments: 1
      };
      pillow.moveTo(0, 0);
      pillow.lineTo(0, 0.2);
      pillow.lineTo(0.3, 0.2);
      pillow.lineTo(0.3, 0);
      pillow.lineTo(0, 0);

      const texture = new THREE.TextureLoader();
      const foundationMaterial = new THREE.MeshPhongMaterial({
        color: this.color,
        map: texture.load("/materials/bed.jpg")
      });
      const legMaterial = new THREE.MeshPhongMaterial({map: texture.load("/materials/wood.jpg")});
      const pillowGeometry = new THREE.ExtrudeBufferGeometry(pillow, extrudeSettings);
      const pillowMaterial = new THREE.MeshPhongMaterial({color: this.pillowColor, map: texture.load("/materials/pillow.jpg")});

      const blanketGeometry = new THREE.BoxBufferGeometry(0.5, 0.05, 0.7);
      const blanketMaterial = new THREE.MeshPhongMaterial({color: this.blanketColor, map: texture.load("/materials/blanket.jpg")})

      const foundationMattressObj = new THREE.Mesh(foundation, foundationMaterial);
      const foundationWood = new THREE.Mesh(new THREE.BoxBufferGeometry(this.width, this.height, 0.05), legMaterial);

      const legTopLeft = new THREE.Mesh(leg, legMaterial);
      const legTopRight = new THREE.Mesh(leg, legMaterial);
      const legBottomLeft = new THREE.Mesh(leg, legMaterial);
      const legBottomRight = new THREE.Mesh(leg, legMaterial);

      legBottomRight.position.set(this.width / 2 - 0.05, -0.2, this.height / 2 - 0.05);
      legBottomLeft.position.set(-this.width / 2 + 0.05, -0.2, this.height / 2 - 0.05);
      legTopLeft.position.set(-this.width / 2 + 0.05, -0.2, -this.height / 2 + 0.05);
      legTopRight.position.set(this.width / 2 - 0.05, -0.2, -this.height / 2 + 0.05);
      foundationWood.position.y = -0.075;
      foundationMattressObj.rotateX(Math.PI / 2);
      foundationWood.rotateX(Math.PI / 2);

      const bedGroup = new THREE.Group();
      bedGroup.add(foundationMattressObj).add(foundationWood).add(legTopRight).add(legTopLeft).add(legBottomLeft).add(legBottomRight);

      for (let i = 0; i < this.panels; i++) {
        const pillowObj = this.getPillow(pillowGeometry, pillowMaterial, i);
        const blanketObj = this.getBlanket(blanketGeometry, blanketMaterial, i);
        bedGroup.add(pillowObj);
        bedGroup.add(blanketObj);
      }
      return bedGroup;
    }
  }

  //Luggage classes
  class Luggage {
    width;
    height;
    depth;
    color;
    textureLoader = new THREE.TextureLoader();

    constructor(width, height, depth, color) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.color = color;

      if(this.constructor === Luggage) {
        throw new Error("Luggage is an abstract class and cannot be instantiated");
      }
    }
    getObject() {
      throw new Error("Method getObject() must be implemented!");
    }

  }

  class LuggageWithWheels extends Luggage {
    handleHeight;
    wheelSets;
    constructor(width, height, depth, color, wheelSets = 1, handleHeight = height/3) {
      super(width, height, depth, color);
      this.handleHeight = handleHeight;
      this.wheelSets = wheelSets;
    }
    getObject() {
      const widthWall = new THREE.BoxBufferGeometry(this.width, this.height, 0.01);
      const heightWall = new THREE.BoxBufferGeometry(0.01, this.height, this.depth/2 - 0.025);
      const depthWall = new THREE.BoxBufferGeometry(this.width, 0.01, this.depth/2 -0.025);

      const zipWidth = new THREE.BoxBufferGeometry(this.width, 0.01, 0.025);
      const zipHeight = new THREE.BoxBufferGeometry(0.01, this.height, 0.025);

      const handleSide = new THREE.BoxBufferGeometry(0.02, this.handleHeight, 0.02);
      const handleMiddle = new THREE.BoxBufferGeometry(this.width/3 + 0.02, 0.02, 0.02);

      const wallMaterial = new THREE.MeshPhongMaterial({color: this.color});
      const zipTexture = this.textureLoader.load("materials/zip.jpg");
      zipTexture.wrapS = THREE.RepeatWrapping;
      zipTexture.wrapT = THREE.RepeatWrapping;

      const zipMaterial = new THREE.MeshPhongMaterial({map: zipTexture});
      const handleMaterial = new THREE.MeshPhongMaterial({color: 0x000000});

      const depthWallTopFront = new THREE.Mesh(depthWall, wallMaterial);
      const depthWallTopBack = depthWallTopFront.clone();
      const depthWallBottomFront = depthWallTopFront.clone();
      const depthWallBottomBack = depthWallTopFront.clone();

      depthWallTopFront.position.set(0, this.height/2, -this.depth/2 + 0.05);
      depthWallTopBack.position.set(0, this.height/2, this.depth/2 - 0.05);
      depthWallBottomFront.position.set(0, -this.height/2, -this.depth/2 + 0.05);
      depthWallBottomBack.position.set(0, -this.height/2, this.depth/2 - 0.05);

      const heightWallLeftFront = new THREE.Mesh(heightWall, wallMaterial);
      const heightWallLeftBack = heightWallLeftFront.clone();
      const heightWallRightFront = heightWallLeftFront.clone();
      const heightWallRightBack = heightWallLeftFront.clone();

      heightWallLeftFront.position.set(-this.width/2, 0, -this.depth/2 +0.05);
      heightWallLeftBack.position.set(-this.width/2, 0, this.depth/2 - 0.05);
      heightWallRightFront.position.set(this.width/2, 0, -this.depth/2 + 0.05);
      heightWallRightBack.position.set(this.width/2, 0, this.depth/2 - 0.05);

      const widthWallFront = new THREE.Mesh(widthWall, wallMaterial);
      const widthWallBack = widthWallFront.clone();

      widthWallBack.position.set(0,0, this.depth/2 - 0.0125);
      widthWallFront.position.set(0,0, -this.depth/2 + 0.0125);

      const zipLeft = new THREE.Mesh(zipHeight, zipMaterial);
      const zipRight = zipLeft.clone();
      const zipTop = new THREE.Mesh(zipWidth, zipMaterial);
      const zipBottom = zipTop.clone();

      zipLeft.position.set(-this.width/2, 0, 0);
      zipRight.position.set(this.width/2, 0, 0);
      zipTop.position.set(0, this.height/2, 0);
      zipBottom.position.set(0, -this.height/2, 0);

      const handleLeft = new THREE.Mesh(handleSide, handleMaterial);
      const handleRight = handleLeft.clone();
      const handleMiddleObj = new THREE.Mesh(handleMiddle, handleMaterial);

      handleLeft.position.set(-this.width/5, this.height/2 + this.handleHeight/2, 0);
      handleRight.position.set(this.width/5, this.height/2 + this.handleHeight/2, 0);
      handleMiddleObj.position.set(0, this.height/2 + this.handleHeight, 0);

      const LuggageGroup = new THREE.Group()
        .add(depthWallTopFront).add(depthWallTopBack)
        .add(depthWallBottomFront).add(depthWallBottomBack)
        .add(heightWallLeftFront).add(heightWallLeftBack)
        .add(heightWallRightFront).add(heightWallRightBack)
        .add(widthWallFront).add(widthWallBack)
        .add(zipLeft).add(zipRight)
        .add(zipTop).add(zipBottom)
        .add(handleLeft).add(handleRight)
        .add(handleMiddleObj);

      for (let i = 0; i < this.wheelSets; i++) {
        const outsideGeometry = new THREE.CylinderBufferGeometry(0.03, 0.03, 0.02, 32, 16);
        const insideGeometry = new THREE.CylinderBufferGeometry(0.01, 0.01, 0.022, 32, 16);

        const singleWheelGroup1 = new THREE.Group()
          .add(new THREE.Mesh(outsideGeometry, handleMaterial))
          .add(new THREE.Mesh(insideGeometry, new THREE.MeshPhongMaterial({color: 0xdffffff})));

        const singleWheelGroup2 = singleWheelGroup1.clone();
        singleWheelGroup1.position.set(-this.width/2 + this.width/4, -this.height/2 - 0.015, Math.pow(-1, i) * this.depth/2);
        singleWheelGroup2.position.set(this.width/2 - this.width/4, -this.height/2 - 0.015, Math.pow(-1, i) * this.depth/2);

        singleWheelGroup2.rotateZ(Math.PI/2);
        singleWheelGroup1.rotateZ(Math.PI/2);
        LuggageGroup
          .add(singleWheelGroup1)
          .add(singleWheelGroup2);
      }
      return LuggageGroup;
    }
  }

  class Briefcase extends Luggage {
    isOpen;
    constructor(width, height, depth, color, isOpen) {
      super(width, height, depth, color);
      this.isOpen = isOpen;
    }
    getObject() {

    }
  }

  //wall material
  const wallMaterial = new THREE.MeshPhongMaterial({color: 0xd2dfb4, shininess: 100});
  //Bed materials
  const bedFoundationMaterial = new THREE.MeshPhongMaterial({color: 'white', opacity: 0});

  //Outside walls
  const westWall11 = new THREE.BoxGeometry(0.2, 2, 3);
  const westWall1Bottom = new THREE.BoxGeometry(0.2, 0.6, 2);
  const westWall1Top = new THREE.BoxGeometry(0.2, 0.6, 2);
  const westWall12 = new THREE.BoxGeometry(0.2, 2, 1);
  const westWall2 = new THREE.BoxGeometry(0.2, 0.2, 1);
  const westWall3 = new THREE.BoxGeometry(0.2, 2, 4);

  const eastWall11 = new THREE.BoxGeometry(0.2, 2, 2);
  const eastWall1Bottom = new THREE.BoxGeometry(0.2, 0.6, 2);
  const eastWall1Top = new THREE.BoxGeometry(0.2, 0.6, 2);
  const eastWall12 = new THREE.BoxGeometry(0.2, 2, 2);

  const eastWall21 = new THREE.BoxGeometry(0.2, 2, 0.2);
  const eastWall2Bottom = new THREE.BoxGeometry(0.2, 1.3, 1.1);
  const eastWall2Top = new THREE.BoxGeometry(0.2, 0.2, 1.1);
  const eastWall22 = new THREE.BoxGeometry(0.2, 2, 3.6);

  const southWall1 = new THREE.BoxGeometry(0.2, 2, 4.2);

  const southWall21 = new THREE.BoxGeometry(0.2, 2, 2);
  const southWall2Bottom = new THREE.BoxGeometry(0.2, 0.6, 3);
  const southWall2Top = new THREE.BoxGeometry(0.2, 0.6, 3);
  const southWall22 = new THREE.BoxGeometry(0.2, 2, 2);

  const northWall11 = new THREE.BoxGeometry(0.2, 2, 1.);
  const northWall1Bottom = new THREE.BoxGeometry(0.2, 0.6, 1.5);
  const northWall1Top = new THREE.BoxGeometry(0.2, 0.6, 1.5);
  const northWall12 = new THREE.BoxGeometry(0.2, 2, 1.2);


  const northWall3 = new THREE.BoxGeometry(0.2, 2, 4);

  //Inside walls
  const officeWall1 = new THREE.BoxBufferGeometry(0.2, 2, 0.2);
  const officeWall2 = new THREE.BoxBufferGeometry(0.2, 0.2, 1);
  const officeWall3 = new THREE.BoxBufferGeometry(0.2, 2, 4.6);
  //Corridor
  const corridorWall11 = new THREE.BoxBufferGeometry(0.2, 2, 5);
  const corridorWall12 = new THREE.BoxBufferGeometry(0.2, 2, 1);
  const corridorWall13 = new THREE.BoxBufferGeometry(0.2, 0.2, 1);

  const corridorWall21 = new THREE.BoxBufferGeometry(0.2, 2, 1);
  const corridorWall22 = new THREE.BoxBufferGeometry(0.2, 0.2, 1);
  const corridorWall23 = new THREE.BoxBufferGeometry(0.2, 2, 3);
  const corridorWall24 = new THREE.BoxBufferGeometry(0.2, 0.2, 1);
  const corridorWall25 = new THREE.BoxBufferGeometry(0.2, 2, 1);

  //Kitchen
  const kitchenWall1 = new THREE.BoxBufferGeometry(0.2, 2, 4);
  //living room
  const livingRoomWall1 = new THREE.BoxBufferGeometry(0.2, 2, 4.25);
  const livingRoomWall2 = new THREE.BoxBufferGeometry(0.2, 2, 1);
  const livingRoomWall31 = new THREE.BoxBufferGeometry(0.2, 2, 0.55);
  const livingRoomWall32 = new THREE.BoxBufferGeometry(0.2, 0.2, 1);
  const livingRoomWall33 = new THREE.BoxBufferGeometry(0.2, 2, 0.75);
  //Toilet
  const toiletWall1 = new THREE.BoxBufferGeometry(0.2, 2, 0.6);
  const toiletWall2 = new THREE.BoxBufferGeometry(0.2, 0.2, 1);
  const toiletWall3 = new THREE.BoxBufferGeometry(0.2, 2, 0.5);

  //Bed
  const bedFoundation = new THREE.BoxBufferGeometry(2, 0.4, 1.8);

  const westWall11Obj = new THREE.Mesh(westWall11, wallMaterial);
  westWall11Obj.position.set(3.9, 1, 4.5);
  westWall11Obj.receiveShadow = true;
  westWall11Obj.castShadow = true;

  const westWall1BottomObj = new THREE.Mesh(westWall1Bottom, wallMaterial);
  westWall1BottomObj.position.set(3.9, 0.3, 2);
  westWall1BottomObj.receiveShadow = true;
  westWall1BottomObj.castShadow = true;

  const westWall1TopObj = new THREE.Mesh(westWall1Top, wallMaterial);
  westWall1TopObj.position.set(3.9, 1.7, 2);
  westWall1TopObj.receiveShadow = true;
  westWall1TopObj.castShadow = true;

  const westWall12Obj = new THREE.Mesh(westWall12, wallMaterial);
  westWall12Obj.position.set(3.9, 1, 0.5);
  westWall12Obj.receiveShadow = true;
  westWall12Obj.castShadow = true;

  const westWall2Obj = new THREE.Mesh(westWall2, wallMaterial);
  westWall2Obj.position.set(3.9, 1.9, -0.5);
  westWall2Obj.receiveShadow = true;
  westWall2Obj.castShadow = true;

  const westWall3Obj = new THREE.Mesh(westWall3, wallMaterial);
  westWall3Obj.position.set(3.9, 1, -3);
  westWall3Obj.receiveShadow = true;
  westWall3Obj.castShadow = true;

  const eastWall11Obj = new THREE.Mesh(eastWall11, wallMaterial);
  eastWall11Obj.position.set(-6.9, 1, -4);
  eastWall11Obj.receiveShadow = true;
  eastWall11Obj.castShadow = true;

  const eastWall1BottomObj = new THREE.Mesh(eastWall1Bottom, wallMaterial);
  eastWall1BottomObj.position.set(-6.9, 0.3, -2);
  eastWall1BottomObj.receiveShadow = true;
  eastWall1BottomObj.castShadow = true;

  const eastWall1TopObj = new THREE.Mesh(eastWall1Top, wallMaterial);
  eastWall1TopObj.position.set(-6.9, 1.7, -2);
  eastWall1TopObj.receiveShadow = true;
  eastWall1TopObj.castShadow = true;

  const eastWall12Obj = new THREE.Mesh(eastWall12, wallMaterial);
  eastWall12Obj.position.set(-6.9, 1, 0);
  eastWall12Obj.receiveShadow = true;
  eastWall12Obj.castShadow = true;

  const eastWall21Obj = new THREE.Mesh(eastWall21, wallMaterial);
  eastWall21Obj.position.set(-2.9, 1, 1.1);
  eastWall21Obj.receiveShadow = true;
  eastWall21Obj.castShadow = true;
  eastWall21Obj.transparent = true;

  const eastWall2BottomObj = new THREE.Mesh(eastWall2Bottom, wallMaterial);
  eastWall2BottomObj.position.set(-2.9, 0.65, 1.7);
  eastWall2BottomObj.receiveShadow = true;
  eastWall2BottomObj.castShadow = true;
  eastWall2BottomObj.transparent = true;

  const eastWall2TopObj = new THREE.Mesh(eastWall2Top, wallMaterial);
  eastWall2TopObj.position.set(-2.9, 1.9, 1.7);
  eastWall2TopObj.receiveShadow = true;
  eastWall2TopObj.castShadow = true;
  eastWall2TopObj.transparent = true;

  const eastWall22Obj = new THREE.Mesh(eastWall22, wallMaterial);
  eastWall22Obj.position.set(-2.9, 1, 4);
  eastWall22Obj.receiveShadow = true;
  eastWall22Obj.castShadow = true;
  eastWall22Obj.transparent = true;

  const southWall1Obj = new THREE.Mesh(southWall1, wallMaterial);
  southWall1Obj.position.set(-4.9, 1, 0.9);
  southWall1Obj.receiveShadow = true;
  southWall1Obj.castShadow = true;
  southWall1Obj.rotateY(Math.PI / 2);

  const southWall2Obj = new THREE.Mesh(southWall21, wallMaterial);
  southWall2Obj.position.set(-2, 1, 5.9);
  southWall2Obj.receiveShadow = true;
  southWall2Obj.castShadow = true;
  southWall2Obj.rotateY(Math.PI / 2);

  const southWall2BottomObj = new THREE.Mesh(southWall2Bottom, wallMaterial);
  southWall2BottomObj.position.set(0.5, 0.3, 5.9);
  southWall2BottomObj.receiveShadow = true;
  southWall2BottomObj.castShadow = true;
  southWall2BottomObj.rotateY(Math.PI / 2);

  const southWall2TopObj = new THREE.Mesh(southWall2Top, wallMaterial);
  southWall2TopObj.position.set(0.5, 1.7, 5.9);
  southWall2TopObj.receiveShadow = true;
  southWall2TopObj.castShadow = true;
  southWall2TopObj.rotateY(Math.PI / 2);

  const southWall22Obj = new THREE.Mesh(southWall22, wallMaterial);
  southWall22Obj.position.set(3, 1, 5.9);
  southWall22Obj.receiveShadow = true;
  southWall22Obj.castShadow = true;
  southWall22Obj.rotateY(Math.PI / 2);

  const northWall11Obj = new THREE.Mesh(northWall11, wallMaterial);
  northWall11Obj.position.set(3.4, 1, -4.9);
  northWall11Obj.receiveShadow = true;
  northWall11Obj.castShadow = true;
  northWall11Obj.rotateY(Math.PI / 2);

  const northWall1BottomObj = new THREE.Mesh(northWall1Bottom, wallMaterial);
  northWall1BottomObj.position.set(2.2, 0.3, -4.9);
  northWall1BottomObj.receiveShadow = true;
  northWall1BottomObj.castShadow = true;
  northWall1BottomObj.rotateY(Math.PI / 2);

  const northWall1TopObj = new THREE.Mesh(northWall1Top, wallMaterial);
  northWall1TopObj.position.set(2.2, 1.7, -4.9);
  northWall1TopObj.receiveShadow = true;
  northWall1TopObj.castShadow = true;
  northWall1TopObj.rotateY(Math.PI / 2);

  const northWall12Obj = new THREE.Mesh(northWall12, wallMaterial);
  northWall12Obj.position.set(1.2, 1, -4.9);
  northWall12Obj.receiveShadow = true;
  northWall12Obj.castShadow = true;
  northWall12Obj.rotateY(Math.PI / 2);

  const northWall21Obj = new THREE.Mesh(northWall11, wallMaterial);
  northWall21Obj.position.set(0, 1, -4.9);
  northWall21Obj.receiveShadow = true;
  northWall21Obj.castShadow = true;
  northWall21Obj.rotateY(Math.PI / 2);

  const northWall2BottomObj = new THREE.Mesh(northWall1Bottom, wallMaterial);
  northWall2BottomObj.position.set(-1.2, 0.3, -4.9);
  northWall2BottomObj.receiveShadow = true;
  northWall2BottomObj.castShadow = true;
  northWall2BottomObj.rotateY(Math.PI / 2);

  const northWall2TopObj = new THREE.Mesh(northWall1Top, wallMaterial);
  northWall2TopObj.position.set(-1.2, 1.7, -4.9);
  northWall2TopObj.receiveShadow = true;
  northWall2TopObj.castShadow = true;
  northWall2TopObj.rotateY(Math.PI / 2);

  const northWall22Obj = new THREE.Mesh(northWall12, wallMaterial);
  northWall22Obj.position.set(-2.5, 1, -4.9);
  northWall22Obj.receiveShadow = true;
  northWall22Obj.castShadow = true;
  northWall22Obj.rotateY(Math.PI / 2);

  const northWall3Obj = new THREE.Mesh(northWall3, wallMaterial);
  northWall3Obj.position.set(-5, 1, -4.9);
  northWall3Obj.receiveShadow = true;
  northWall3Obj.castShadow = true;
  northWall3Obj.rotateY(Math.PI / 2);

  const corridorWall11Obj = new THREE.Mesh(corridorWall11, wallMaterial);
  corridorWall11Obj.position.set(-0.5, 1, 0.9);
  corridorWall11Obj.receiveShadow = true;
  corridorWall11Obj.castShadow = true;
  corridorWall11Obj.rotateY(Math.PI / 2);

  const corridorWall12Obj = new THREE.Mesh(corridorWall12, wallMaterial);
  corridorWall12Obj.position.set(3.5, 1, 0.9);
  corridorWall12Obj.receiveShadow = true;
  corridorWall12Obj.castShadow = true;
  corridorWall12Obj.rotateY(Math.PI / 2);

  const corridorWall13Obj = new THREE.Mesh(corridorWall13, wallMaterial);
  corridorWall13Obj.position.set(2.5, 1.9, 0.9);
  corridorWall13Obj.receiveShadow = true;
  corridorWall13Obj.castShadow = true;
  corridorWall13Obj.rotateY(Math.PI / 2);

  const corridorWall21Obj = new THREE.Mesh(corridorWall21, wallMaterial);
  corridorWall21Obj.position.set(-2.5, 1, -1);
  corridorWall21Obj.receiveShadow = true;
  corridorWall21Obj.castShadow = true;
  corridorWall21Obj.rotateY(Math.PI / 2);

  const corridorWall22Obj = new THREE.Mesh(corridorWall22, wallMaterial);
  corridorWall22Obj.position.set(-1.5, 1.9, -1);
  corridorWall22Obj.receiveShadow = true;
  corridorWall22Obj.castShadow = true;
  corridorWall22Obj.rotateY(Math.PI / 2);

  const corridorWall23Obj = new THREE.Mesh(corridorWall23, wallMaterial);
  corridorWall23Obj.position.set(0.5, 1, -1);
  corridorWall23Obj.receiveShadow = true;
  corridorWall23Obj.castShadow = true;
  corridorWall23Obj.rotateY(Math.PI / 2);

  const corridorWall24Obj = new THREE.Mesh(corridorWall24, wallMaterial);
  corridorWall24Obj.position.set(2.5, 1.9, -1);
  corridorWall24Obj.receiveShadow = true;
  corridorWall24Obj.castShadow = true;
  corridorWall24Obj.rotateY(Math.PI / 2);

  const corridorWall25Obj = new THREE.Mesh(corridorWall25, wallMaterial);
  corridorWall25Obj.position.set(3.5, 1, -1);
  corridorWall25Obj.receiveShadow = true;
  corridorWall25Obj.castShadow = true;
  corridorWall25Obj.rotateY(Math.PI / 2);

  const kitchenWallObj = new THREE.Mesh(kitchenWall1, wallMaterial);
  kitchenWallObj.position.set(0.5, 1, -3);
  kitchenWallObj.receiveShadow = true;
  kitchenWallObj.castShadow = true;

  const officeWallObj1 = new THREE.Mesh(officeWall1, wallMaterial);
  officeWallObj1.position.set(-3, 1, 0.7);
  officeWallObj1.receiveShadow = true;
  officeWallObj1.castShadow = true;

  const officeWallObj2 = new THREE.Mesh(officeWall2, wallMaterial);
  officeWallObj2.position.set(-3, 1.9, 0.2);
  officeWallObj2.receiveShadow = true;
  officeWallObj2.castShadow = true;

  const officeWallObj3 = new THREE.Mesh(officeWall3, wallMaterial);
  officeWallObj3.position.set(-3, 1, -2.6);
  officeWallObj3.receiveShadow = true;
  officeWallObj3.castShadow = true;

  const livingRoomWall1Obj = new THREE.Mesh(livingRoomWall1, wallMaterial);
  livingRoomWall1Obj.position.set(-0.85, 1, 3);
  livingRoomWall1Obj.receiveShadow = true;
  livingRoomWall1Obj.castShadow = true;
  livingRoomWall1Obj.rotateY(Math.PI / 2);

  const livingRoomWall2Obj = new THREE.Mesh(livingRoomWall2, wallMaterial);
  livingRoomWall2Obj.position.set(1.56, 1, 3.33);
  livingRoomWall2Obj.receiveShadow = true;
  livingRoomWall2Obj.castShadow = true;
  livingRoomWall2Obj.rotateY(Math.PI / 4);

  const livingRoomWall31Obj = new THREE.Mesh(livingRoomWall31, wallMaterial);
  livingRoomWall31Obj.position.set(2.1, 1, 3.71);
  livingRoomWall31Obj.receiveShadow = true;
  livingRoomWall31Obj.castShadow = true;
  livingRoomWall31Obj.rotateY(Math.PI / 2);

  const livingRoomWall32Obj = new THREE.Mesh(livingRoomWall32, wallMaterial);
  livingRoomWall32Obj.position.set(2.65, 1.9, 3.71);
  livingRoomWall32Obj.receiveShadow = true;
  livingRoomWall32Obj.castShadow = true;
  livingRoomWall32Obj.rotateY(Math.PI / 2);

  const livingRoomWall33Obj = new THREE.Mesh(livingRoomWall33, wallMaterial);
  livingRoomWall33Obj.position.set(3.45, 1, 3.71);
  livingRoomWall33Obj.receiveShadow = true;
  livingRoomWall33Obj.castShadow = true;
  livingRoomWall33Obj.rotateY(Math.PI / 2);

  const toiletWall1Obj = new THREE.Mesh(toiletWall1, wallMaterial);
  toiletWall1Obj.position.set(0, 1, 2.6);
  toiletWall1Obj.receiveShadow = true;
  toiletWall1Obj.castShadow = true;

  const toiletWall2Obj = new THREE.Mesh(toiletWall2, wallMaterial);
  toiletWall2Obj.position.set(0, 1.9, 1.9);
  toiletWall2Obj.receiveShadow = true;
  toiletWall2Obj.castShadow = true;

  const toiletWall3Obj = new THREE.Mesh(toiletWall3, wallMaterial);
  toiletWall3Obj.position.set(0, 1, 1.2);
  toiletWall3Obj.receiveShadow = true;
  toiletWall3Obj.castShadow = true;

  const window1 = new WindowPanel(3, 0.7, 4);
  const window1Obj = window1.getObject();
  window1Obj.position.set(0.5, 1, 5.9)
  window1Obj.receiveShadow = true;
  window1Obj.castShadow = true;

  const window2 = new WindowPanel(1, 0.54, 1);
  const window2Obj = window2.getObject();
  window2Obj.position.set(-2.9, 1.53, 1.7)
  window2Obj.rotateY(Math.PI / 2);
  window2Obj.receiveShadow = true;
  window2Obj.castShadow = true;

  const window3 = new WindowPanel(1.1, 0.75, 2);
  const window3Obj = window3.getObject();
  window3Obj.position.set(2.39, 1, -4.9);
  window3Obj.receiveShadow = true;
  window3Obj.castShadow = true;

  const window4 = new WindowPanel(1.3, 0.75, 2);
  const window4Obj = window4.getObject();
  window4Obj.position.set(-1.2, 1, -4.9);
  window4Obj.receiveShadow = true;
  window4Obj.castShadow = true;

  const window5 = new WindowPanel(2, 0.75, 3);
  const window5Obj = window5.getObject();
  window5Obj.position.set(-6.9, 1, -2);
  window5Obj.rotateY(Math.PI / 2);
  window5Obj.receiveShadow = true;
  window5Obj.castShadow = true;

  const window6 = new WindowPanel(2, 0.75, 3);
  const window6Obj = window6.getObject();
  window6Obj.position.set(3.9, 1, 2);
  window6Obj.rotateY(Math.PI / 2);
  window6Obj.receiveShadow = true;
  window6Obj.castShadow = true;

  const bed1 = new Bed(1.8, 1, 1, 0xc6ab7e, 0xd0cfca, 0xd0cfca);
  const bed1Obj = bed1.getObject();
  bed1Obj.position.set(1.1, 0.3, -3.9);
  bed1Obj.rotateY(Math.PI / 2);
  bed1Obj.receiveShadow = true;
  bed1Obj.castShadow = true;

  const bed2 = new Bed(1.8, 1, 1, 0x71647d, 0x4f4f4d, 0x4f4f4d);
  const bed2Obj = bed2.getObject();
  bed2Obj.position.set(3.3, 0.3, -3.9);
  bed2Obj.rotateY(Math.PI / 2);
  bed2Obj.receiveShadow = true;
  bed2Obj.castShadow = true;

  const bed3 = new Bed(1.8, 2, 2, 0xbbeedd, 0xffcff1, 0xffcff1);
  const bed3Obj = bed3.getObject();
  bed3Obj.position.set(-1.25, 0.3, -3.9);
  bed3Obj.rotateY(Math.PI / 2);
  bed3Obj.receiveShadow = true;
  bed3Obj.castShadow = true;

  const fireplace = new Fireplace(0.9, 2);
  const fireplaceObj = fireplace.getObject();
  fireplaceObj.position.set(-5, 1, 0.5);
  fireplaceObj.receiveShadow = true;
  fireplaceObj.castShadow = true;

  const chair = new Chair(0xffcff1);
  const chair1Obj = chair.getObject();
  chair1Obj.position.set(0, 0.3, 4.5);
  chair1Obj.receiveShadow = true;
  chair1Obj.castShadow = true;

  const chair2Obj = chair1Obj.clone();
  chair2Obj.position.set(0, 0.3, 5.5);
  chair2Obj.rotateY(2 * Math.PI / 2);
  chair2Obj.receiveShadow = true;
  chair2Obj.castShadow = true;

  const chair3Obj = chair1Obj.clone();
  chair3Obj.position.set(-0.5, 0.3, 5);
  chair3Obj.rotateY(Math.PI / 2);
  chair3Obj.receiveShadow = true;
  chair3Obj.castShadow = true;

  const chair4Obj = chair1Obj.clone();
  chair4Obj.position.set(0.5, 0.3, 5);
  chair4Obj.rotateY(-Math.PI / 2);
  chair4Obj.receiveShadow = true;
  chair4Obj.castShadow = true;

  const table1 = new Table(1, 0.8, true, 'crimson');
  const table1Obj = table1.getObject();
  table1Obj.position.set(0, 0.6, 5);
  table1Obj.receiveShadow = true;
  table1Obj.castShadow = true;

  const painting1 = new Painting(0.4, 0.5, 0.01, "https://images.unsplash.com/photo-1618331833071-ce81bd50d300?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxzZWFyY2h8M3x8YWJzdHJhY3QlMjBhcnR8ZW58MHx8MHx8&w=1000&q=80");
  const painting1Obj = painting1.getObject();
  painting1Obj.position.set(-2, 1.4, 3.1);

  const painting2 = new Painting(0.5, 0.3, 0.01, "https://cpb-us-e2.wpmucdn.com/newsevents.illinoisstate.edu/dist/c/2/files/2017/09/abstract-art-scholar.jpg");
  const painting2Obj = painting2.getObject();
  painting2Obj.position.set(-1.3, 1.4, 3.1);

  const painting3 = new Painting(0.5, 0.5, 0.01, "/materials/gochev1.jpg");
  const painting3Obj = painting3.getObject();
  painting3Obj.position.set(-0.5, 1.4, 3.1);

  const painting4 = new Painting(0.6, 0.4, 0.01, "/materials/kandinsky.jpg");
  const painting4Obj = painting4.getObject();
  painting4Obj.position.set(0.3, 1.4, 3.1);

  const painting5 = new Painting(0.8, 1, 0.05, "/materials/saturn.jpg");
  const painting5Obj = painting5.getObject();
  painting5Obj.position.set(-5, 1.3, -4.8);

  const painting6 = new Painting(0.8, 1, 0.05, "https://upload.wikimedia.org/wikipedia/commons/thumb/5/55/Visi%C3%B3n_fantasmal_por_Francisco_de_Goya.jpg/800px-Visi%C3%B3n_fantasmal_por_Francisco_de_Goya.jpg");
  const painting6Obj = painting6.getObject();
  painting6Obj.position.set(1, 1.3, 0.8);
  painting6Obj.rotateY(-2 * Math.PI / 2);

  const painting7 = new Painting(0.4, 0.6, 0.02, "https://media.nga.gov/iiif/7f6da94c-914c-48e3-88ff-fbe75e4ed079/full/!740,560/0/default.jpg");
  const painting7Obj = painting7.getObject();
  painting7Obj.position.set(-2.9, 1.3, -2);
  painting7Obj.rotateY(Math.PI / 2);

  const painting8 = new Painting(0.7, 0.4, 0.02, "https://cdn.shopify.com/s/files/1/1016/1455/collections/imagesTZL4D1NH.jpg?v=1624171120");
  const painting8Obj = painting8.getObject();
  painting8Obj.position.set(-2.9, 1.3, -3);
  painting8Obj.rotateY(Math.PI / 2);

  const painting9 = new Painting(2, 0.8, 0.06, "https://upload.wikimedia.org/wikipedia/commons/thumb/6/68/Claude_Monet_-_Stacks_of_Wheat_%28End_of_Summer%29_-_1985.1103_-_Art_Institute_of_Chicago.jpg/1200px-Claude_Monet_-_Stacks_of_Wheat_%28End_of_Summer%29_-_1985.1103_-_Art_Institute_of_Chicago.jpg");
  const painting9Obj = painting9.getObject();
  painting9Obj.position.set(0.4, 1.3, -3);
  painting9Obj.rotateY(-Math.PI / 2);

  const painting10 = new Painting(0.6, 0.6, 0.02, "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Piet_Mondriaan%2C_1942_-_New_York_City_I.jpg/220px-Piet_Mondriaan%2C_1942_-_New_York_City_I.jpg");
  const painting10Obj = painting10.getObject();
  painting10Obj.position.set(3.8, 1.3, -3);
  painting10Obj.rotateY(-Math.PI / 2);

  const painting11 = new Painting(0.4, 0.4, 0.02, "/materials/mondrian.jpg");
  const painting11Obj = painting11.getObject();
  painting11Obj.position.set(3.8, 1.3, -2.2);
  painting11Obj.rotateY(-Math.PI / 2);

  const painting12 = new Painting(0.6, 0.4, 0.02, "https://upload.wikimedia.org/wikipedia/commons/4/47/Piet_Mondriaan_-_03.jpg");
  const painting12Obj = painting12.getObject();
  painting12Obj.position.set(3.8, 1.3, -4);
  painting12Obj.rotateY(-Math.PI / 2);

  const painting13 = new Painting(0.5, 0.6, 0.02, "https://iiif.micr.io/TZCqF/full/1280,/0/default.jpg");
  const painting13Obj = painting13.getObject();
  painting13Obj.position.set(0.6, 1.3, -2);
  painting13Obj.rotateY(Math.PI / 2);

  const painting14 = new Painting(0.7, 0.4, 0.02, "/materials/van-gogh1.jpg");
  const painting14Obj = painting14.getObject();
  painting14Obj.position.set(0.6, 1.3, -3);
  painting14Obj.rotateY(Math.PI / 2);

  const desk1 = new Desk(2, 0.8, 3);
  const desk1Obj = desk1.getObject();
  desk1Obj.position.set(-4.2, 0.6, -3.5);
  // desk1Obj.position.set(5,5,0);

  const desk2 = new Desk(1.2, 0.4, 4);
  const desk2Obj = desk2.getObject();
  desk2Obj.position.set(1.25, 0.6, -1.3);
  // desk2Obj.position.set(3,5, 0);
  const desk3Obj = desk2Obj.clone();
  desk3Obj.position.set(3.7, 0.6, -1.7);
  desk3Obj.rotateY(Math.PI / 2);

  const chair5 = new Chair(0x000000);
  const chair5Obj = chair5.getObject();
  chair5Obj.position.set(-4.5, 0.3, -4);

  const chair6 = new Chair(0x123fa2);
  const chair6Obj = chair6.getObject();
  chair6Obj.position.set(1, 0.3, -1.5);

  const chair7 = new Chair(0xfa2bb3);
  const chair7Obj = chair7.getObject();
  chair7Obj.position.set(3.5, 0.3, -1.5);
  chair7Obj.rotateY(Math.PI / 2);

  const kitchenFloor1 = new Flooring(4, 0.01, 3, "https://t4.ftcdn.net/jpg/01/97/71/71/360_F_197717166_UowHyPmYH2g6b2bH3kgXD1Mcbh1UDtLY.jpg").getObject();
  kitchenFloor1.position.set(-1,0.01,4.5);

  const kitchenFloor2 = new Flooring(3, 0.01, 2.5, "https://t4.ftcdn.net/jpg/01/97/71/71/360_F_197717166_UowHyPmYH2g6b2bH3kgXD1Mcbh1UDtLY.jpg").getObject();
  kitchenFloor2.position.set(2.5, 0.01, 4.6);

  const frontFloor = new Flooring(4, 0.01, 8, "https://t4.ftcdn.net/jpg/01/97/71/71/360_F_197717166_UowHyPmYH2g6b2bH3kgXD1Mcbh1UDtLY.jpg").getObject();
  frontFloor.position.set(2,0.01,-0.6);

  const backFloor = new Flooring(7, 0.01, 6, "https://t4.ftcdn.net/jpg/01/97/71/71/360_F_197717166_UowHyPmYH2g6b2bH3kgXD1Mcbh1UDtLY.jpg").getObject();
  backFloor.position.set(-3.4,0.01,-2);

  const bathRoomFloor = new Flooring(3, 0.01, 2, "https://img.cgaxis.com/2019/02/black_tiles_3_diffuse.jpg").getObject();
  bathRoomFloor.position.set(-1.5,0.01,2);
  const leftWallToilet = new Flooring(0.01, 2, 2.7, "https://img.cgaxis.com/2019/02/black_tiles_3_diffuse.jpg").getObject();
  leftWallToilet.position.set(-1.5,1,2.9);
  leftWallToilet.rotateY(Math.PI/2);

  const rightWallToilet = leftWallToilet.clone();
  rightWallToilet.position.set(-1.5,1,1);

  const backWallToilet1 = new Flooring(2, 1.4, 0.01, "https://img.cgaxis.com/2019/02/black_tiles_3_diffuse.jpg").getObject();
  backWallToilet1.position.set(-2.8,0.51,1.9);
  backWallToilet1.rotateY(Math.PI/2);

  const backWallToilet2 = new Flooring(0.67, 0.8, 0.01, "https://img.cgaxis.com/2019/02/black_tiles_3_diffuse.jpg").getObject();
  backWallToilet2.position.set(-2.8,1.6,2.57);
  backWallToilet2.rotateY(Math.PI/2);

  const backWallToilet3 = new Flooring(1.33, 0.2, 0.01, "https://img.cgaxis.com/2019/02/black_tiles_3_diffuse.jpg").getObject();
  backWallToilet3.position.set(-2.8,1.9,1.65);
  backWallToilet3.rotateY(Math.PI/2);

  const backWallToilet4 = new Flooring(0.2, 0.6, 0.01, "https://img.cgaxis.com/2019/02/black_tiles_3_diffuse.jpg").getObject();
  backWallToilet4.position.set(-2.8,1.5,1.1);
  backWallToilet4.rotateY(Math.PI/2);

  const cupboard1 = new Cupboard(1.6,1.2,0.3,3,2, 0).getObject();
  cupboard1.position.set(-3.3,0.62,-1.5);
  cupboard1.rotateY(Math.PI/2);

  const cupboard2 = new Cupboard(1.6,0.5,0.3,1,3, 0).getObject();
  cupboard2.position.set(0,0.26,3.25);

  const shoeCupboard = new Cupboard(0.75,0.6,0.25,4,3, 0).getObject();
  shoeCupboard.position.set(3.4,0.32,0.65);

  const monitor1 = new Monitor(0.8,false, "/materials/windows-desktop.jpg").getObject();
  monitor1.position.set(-4,0.95,-3.3);
  monitor1.rotateY(2*Math.PI/2);

  const TV = new Monitor(1.2, true, "https://iatkv.tmgrup.com.tr/d9387f/0/0/0/0/625/417?u=https%3A%2F%2Fitkv.tmgrup.com.tr%2F2021%2F01%2F07%2Fyaprak-dokumu-ali-riza-bey-kim-yaprak-dokumu-ali-riza-bey-kac-yasinda-nereli-1610021741176.jpg&mw=616").getObject();
  TV.position.set(0,0.85,3.2);

  const kitchenCupboard = new Cupboard(1, 0.8 , 0.5, 3, 2, true).getObject();
  kitchenCupboard.position.set(-2.5,0.42,5.3);
  kitchenCupboard.rotateY(-Math.PI/2);

  const kitchenCupboardWall = new Cupboard(2.6, 0.4 , 0.3, 1, 4, true).getObject();
  kitchenCupboardWall.position.set(-2.6,1.6,4.45);
  kitchenCupboardWall.rotateY(-Math.PI/2);

  const bedsideTable1 = new Cupboard(0.5, 0.5,0.5, 2, 1, true).getObject();
  bedsideTable1.position.set(-2.55,0.26,-4.5);
  bedsideTable1.rotateY(2*Math.PI/2);

  const bedsideTable2 = bedsideTable1.clone();
  bedsideTable2.position.set(0.05,0.26,-4.5);

  const bedsideTable3 = new Cupboard(1, 0.5, 0.3, 2, 3, true).getObject();
  bedsideTable3.position.set(2.2,0.26,-4.5);
  bedsideTable3.rotateY(2*Math.PI/2);

  const furnace = new Furnace(0.8, 0.8, 0.5).getObject();
  furnace.position.set(-2.5,0.42,4.35);
  furnace.rotateY(Math.PI/2);

  const sinkKitchen = new Sink(0.8,0.8,0.5).getObject();
  const sinkToilet = sinkKitchen.clone();

  sinkKitchen.position.set(-2.5,0.42,3.53);
  sinkKitchen.rotateY(-Math.PI /2);

  sinkToilet.position.set(-1.5, 0.42, 2.7);

  const wardrobe = new Cupboard(1.1, 1.7, 0.4, 1 , 2 , true).getObject();
  wardrobe.position.set(-0.2, 0.86, -1.3);

  const bedroomChair = new Chair('white').getObject();
  bedroomChair.position.set(-2.3, 0.5, -1.47);
  bedroomChair.rotateY(2*Math.PI/2);
  bedroomChair.rotateX(-Math.PI / 8);

  const luggage1 = new LuggageWithWheels(0.4, 0.5, 0.2, 'red', 2).getObject();
  luggage1.position.set(0,0.3,0);

  //TODO: Make briefcase, roaches
  //TODO: Fix floorings

  const toilet = Toilet.getObject();
  toilet.position.set(-2.5,0.5,2);
  toilet.rotateY(-Math.PI/2);
  scene.add(toilet);

  scene.add(bedsideTable2);
  scene.add(luggage1);
  scene.add(wardrobe);
  scene.add(bedroomChair);
  scene.add(sinkKitchen);
  scene.add(sinkToilet);
  scene.add(furnace);
  scene.add(bedsideTable1);
  scene.add(bedsideTable3);
  scene.add(kitchenCupboard);
  scene.add(kitchenCupboardWall);
  scene.add(monitor1);
  scene.add(TV);
  scene.add(cupboard1);
  scene.add(cupboard2);
  scene.add(shoeCupboard);
  scene.add(kitchenFloor1);
  scene.add(kitchenFloor2);
  scene.add(frontFloor);
  scene.add(backFloor);
  scene.add(bathRoomFloor);
  scene.add(leftWallToilet);
  scene.add(rightWallToilet);
  scene.add(backWallToilet1);
  scene.add(backWallToilet2);
  scene.add(backWallToilet3);
  scene.add(backWallToilet4);

  scene.add(chair5Obj);
  scene.add(chair6Obj);
  scene.add(chair7Obj);
  scene.add(desk2Obj);
  scene.add(desk3Obj);
  scene.add(desk1Obj);
  scene.add(painting1Obj)
  scene.add(painting2Obj)
  scene.add(painting3Obj)
  scene.add(painting4Obj)
  scene.add(painting5Obj)
  scene.add(painting6Obj)
  scene.add(painting7Obj)
  scene.add(painting8Obj)
  scene.add(painting9Obj)
  scene.add(painting10Obj)
  scene.add(painting11Obj)
  scene.add(painting12Obj)
  scene.add(painting13Obj)
  scene.add(painting14Obj)

  scene.add(table1Obj);

  scene.add(chair1Obj);
  scene.add(chair2Obj);
  scene.add(chair3Obj);
  scene.add(chair4Obj);

  scene.add(fireplaceObj);
  scene.add(bed1Obj);
  scene.add(bed2Obj);
  scene.add(bed3Obj);

  scene.add(window1Obj);
  scene.add(window2Obj);
  scene.add(window3Obj);
  scene.add(window4Obj);
  scene.add(window5Obj);
  scene.add(window6Obj);

  scene.add(westWall11Obj);
  scene.add(westWall1BottomObj);
  scene.add(westWall1TopObj);
  scene.add(westWall12Obj);

  scene.add(westWall2Obj);
  scene.add(westWall3Obj);

  scene.add(eastWall11Obj);
  scene.add(eastWall1BottomObj);
  scene.add(eastWall1TopObj);
  scene.add(eastWall12Obj);

  scene.add(eastWall21Obj);
  scene.add(eastWall2BottomObj);
  scene.add(eastWall2TopObj);
  scene.add(eastWall22Obj);

  scene.add(southWall1Obj);
  scene.add(southWall2Obj);
  scene.add(southWall2BottomObj);
  scene.add(southWall2TopObj);
  scene.add(southWall22Obj);

  scene.add(northWall11Obj);
  scene.add(northWall1BottomObj);
  scene.add(northWall1TopObj);
  scene.add(northWall12Obj);

  scene.add(northWall21Obj);
  scene.add(northWall2BottomObj);
  scene.add(northWall2TopObj);
  scene.add(northWall22Obj);

  scene.add(northWall3Obj);

  scene.add(corridorWall11Obj);
  scene.add(corridorWall12Obj);
  scene.add(corridorWall13Obj);

  scene.add(corridorWall21Obj);
  scene.add(corridorWall22Obj);
  scene.add(corridorWall23Obj);
  scene.add(corridorWall24Obj);
  scene.add(corridorWall25Obj);

  scene.add(kitchenWallObj);

  scene.add(officeWallObj1);
  scene.add(officeWallObj2);
  scene.add(officeWallObj3);

  scene.add(livingRoomWall1Obj);
  scene.add(livingRoomWall2Obj);

  scene.add(livingRoomWall31Obj);
  scene.add(livingRoomWall32Obj);
  scene.add(livingRoomWall33Obj);

  scene.add(toiletWall1Obj);
  scene.add(toiletWall2Obj);
  scene.add(toiletWall3Obj);
</script>

</body>
</html>


